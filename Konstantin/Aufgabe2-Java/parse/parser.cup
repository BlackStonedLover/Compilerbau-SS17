/*
 * parser.cup -- SPL parser specification
 */


package parse;

import java_cup.runtime.*;


parser code {:

  public void syntax_error(Symbol currToken) {
    System.out.println(
      "**** Error: syntax error" +
      " in line " + currToken.left +
      ", column " + currToken.right
    );
    System.exit(0);
  }

:}


terminal ARRAY,IF,ELSE,VAR,WHILE,REF,PROC,OF,TYPE,LE,GE,ASGN,PLUS,MINUS,STAR,SLASH,EQ,NE,LT,GT,RPAREN,LPAREN,RCURL,LCURL,RBRACK,LBRACK,SEMIC,COMMA,COLON;
terminal Integer INTLIT;
terminal String IDENT;


non terminal		MatchSign,Operator,Program,TypV,Prozedur,Typ,Array,Paralist,Deklaration,StmtList,Stmt,Para,LeftHandSide,RightHandSide,Expressions,Ausdruck, IfStmt,WhileStmt,AssignStmt,ProcCall,OptElse,Variable,VariableArray;

start with Program;


Program::=|
      TypV:t Program:h
	  {: RESULT = new DecList((dec)h, (DecList)t) ;:}
      |
      Prozedur:t Program:h
	  {: RESULT = new DecList((Dec)h, (DecList)t) ;:}
      ;

/*
eventueller Auruf von .newSym() nötig anstatt Sym sn
*/
TypV::=TYPE:t IDENT:sn EQ Typ:tt SEMIC
{: RESULT = new TypeDec(tleft,tright,(Sym) sn, (Ty)tt ;:}
;

Typ::=
IDENT:id
{: RESULT = id ;:}
|
Array: a
{: RESULT = a ;:}
;


Array::=
<<<<<<< HEAD
ARRAY:a LBRACK INTLIT:count RBRACK OF Array
=======
ARRAY:a LBRACK INTLIT:count RBRACK OF Array:t
>>>>>>> 90047f3c6803d7c2705df5d6958e6488b0616c0c
{: RESULT = new ArrayTy(aleft, aright, count, (Ty t)t) ;:}
|
ARRAY:a LBRACK INTLIT:count RBRACK OF IDENT:t
{: RESULT = new ArrayTy(aleft, aright, count, (Ty)t) ;:}
;

Prozedur::=
PROC:p IDENT:s LPAREN Paralist RPAREN LCURL Deklaration:p StmtList:b RCURL
{: RESULT = new ProcDec(pleft, pright, (Sym)s, (DecList)p, (StmList)b) ;:};

/*

*/
Deklaration ::=
{: RESULT =  ;:}
|
VAR IDENT COLON IDENT SEMIC Deklaration
{: RESULT ;:};

Paralist::=
{: RESULT ;:}
|
Para COMMA Paralist
{: RESULT ;:}
|
Para
{: RESULT ;:};

Para::= IDENT COLON Typ
{: RESULT ;:}
|
REF IDENT COLON Typ
{: RESULT ;:};


/*
TODO: Stmtlist evtl mit boolean? da überprüfung auf empty
*/
StmtList::=
{: RESULT = new StmList() ;:}
|
Stmt:h StmtList:t
{: RESULT = new StmList((Stm h)h, (StmList t)t) ;:};


Stmt::=
IfStmt:i
{: RESULT = i; :}
|
WhileStmt: w
{: RESULT = w; :}
|
AssignStmt: a
{: RESULT = a; :}
|
ProcCall: pc
{: RESULT = pc; :}
|
/*
TODO: EMPTY STATEMENT
*/
SEMIC:s
{: RESULT = (sleft,sright) ; :}
;

IfStmt::=IF LPAREN Expressions RPAREN Stmt OptElse
{: RESULT = ;:};

OptElse::=
{: RESULT ;:}
|
ELSE Stmt
{: RESULT ;:}
;

<<<<<<< HEAD
WhileStmt::=
WHILE LPAREN Ausdruck RPAREN Stmt {;
=======
<<<<<<< HEAD
WhileStmt::=
WHILE LPAREN Ausdruck RPAREN Stmt
=======
WhileStmt::= 
WHILE LPAREN Ausdruck RPAREN Stmt 
<<<<<<< HEAD
{: RESULT  ;};
=======
>>>>>>> 90047f3c6803d7c2705df5d6958e6488b0616c0c
{: RESULT = ;};
>>>>>>> 45b1336baa0046ff0f116f17df55e4b9cb50b9f2
>>>>>>> 941da97ee3b2bd08edb6d6161d01ce9dfb49f6ca

AssignStmt::=
  LeftHandSide:l ASGN RightHandSide:r
  {: RESULT = new AssignStmt(lleft,rright, (Var)v, (Exp)e) ;:}
  ;

ProcCall::=
IDENT LPAREN IDENT RPAREN SEMIC
{: RESULT ;:}
;

LeftHandSide::=
{: RESULT ;:}
|
Variable
{: RESULT ;:};

Variable::=IDENT
{: RESULT ;:}
|
VariableArray
{: RESULT ;:}
;

VariableArray::= VariableArray LBRACK Ausdruck RBRACK
{: RESULT ;:}
|
IDENT LBRACK Ausdruck RBRACK
{: RESULT ;:}
;

RightHandSide::=Expressions
{: RESULT ;:}
;

/*
TODO: Ausdrücke ersetzen
*/
Ausdruck::=
Variable MatchSign Variable|
INTLIT MatchSign INTLIT|
Variable MatchSign INTLIT|
INTLIT MatchSign Variable;

MatchSign::=
LT|
LE|
GE|
GT|
NE|
EQ;

ExpList::=
|
Val Expressions ExpList|
LPAREN Val Expressions RPAREN ExpList|
;

Expressions::=
LT Val|
LE Val|
GE Val|
GT Val|
NE Val|
EQ Val|
MINUS Val|
PLUS Val|
STAR Val|
SLASH Val
;


Val::=
INTLIT |
Variable |
MINUS INTLIT
;

Expressions::=
Variable:v {: RESULT = new VarExp(vleft,vright,v); :}|
Variable Operator INTLIT|
Variable Operator Variable|
INTLIT Operator INTLIT|
Expressions LT Expressions|
Expressions LE Expressions|
Expressions GE Expressions|
Expressions GT Expressions|
Expressions NE Expressions|
Expressions EQ Expressions;


Operator::=
PLUS|
MINUS|
STAR|
SLASH;
