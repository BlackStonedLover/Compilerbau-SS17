/*
 * parser.cup -- SPL parser specification
 */


package parse;

import java_cup.runtime.*;
import abysn.*;
import sym.*;

parser code {:

  public void syntax_error(Symbol currToken) {
    System.out.println(
      "**** Error: syntax error" +
      " in line " + currToken.left +
      ", column " + currToken.right
    );
    System.exit(0);
  }

:}


terminal ARRAY,IF,ELSE,VAR,WHILE,REF,PROC,OF,TYPE,LE,GE,ASGN,PLUS,MINUS,STAR,SLASH,EQ,NE,LT,GT,RPAREN,LPAREN,RCURL,LCURL,RBRACK,LBRACK,SEMIC,COMMA,COLON;
terminal Integer INTLIT;
terminal String IDENT;

non terminal    Dec Program;
non terminal    DecList TypV;
non terminal    DecList Prozedur;
non terminal    ExpList Paralist;
non terminal    ExpList Paralist2;
non terminal    DecList Deklaration;
non terminal    Ty Typ;
non terminal    ArrayTy Array;
non terminal    StmList StmtList;
non terminal    Stm Stmt;
non terminal    Dec Para;
non terminal    Var LeftHandSide;
non terminal    Exp RightHandSide;
non terminal    IfStmt;
non terminal    WhileStmt;
non terminal    AssignStmt;
non terminal    ProcCall;
non terminal    CompoundStmt;
non terminal    Stm OptElse;
non terminal    Variable;
non terminal    Var VariableArray;
non terminal    Exp Expressions;


start with Program;

Program::=|
      TypV:t Program:h
	  {: RESULT = new DecList((dec)h, (DecList)t) ;:}
      |
      Prozedur:t Program:h
	  {: RESULT = new DecList((Dec)h, (DecList)t) ;:}
      ;

/*
eventueller Auruf von .newSym() n√∂tig anstatt Sym sn
*/
TypV::=TYPE:t IDENT:sn EQ Typ:tt SEMIC
{: RESULT = new TypeDec(t.left,t.right,(Sym) sn, (Ty)tt ;:}
;

Typ::=
IDENT:id
{: RESULT = new NameTy(id.left,id.right,Sym.newSym(id)) ;:}
|
Array: a
{: RESULT = a ;:}
;


Array::=

ARRAY:a LBRACK INTLIT:count RBRACK OF Array:t
{: RESULT = new ArrayTy(a.left, a.right, count, (Ty)t) ;:}
|
ARRAY:a LBRACK INTLIT:count RBRACK OF IDENT:t
{: RESULT = new ArrayTy(a.left, a.right, count, (Ty)t) ;:}
;

Prozedur::=
PROC:p IDENT:s LPAREN Paralist RPAREN LCURL Deklaration:p StmtList:b RCURL
{: RESULT = new ProcDec(p.left, p.right, (Sym)s, (DecList)p, (StmList)b) ;:};

Deklaration ::=
{: RESULT = new DecList() ;:}
|
VAR IDENT:n COLON Typ:t SEMIC Deklaration:d
{: RESULT = new DecList(new VarDec(n.left,n.right,Sym.newSym(n),t),d) ;:};

Paralist::=
{: RESULT = new DecList() ; :}
|
Paralist2:pl
{: RESULT = pl;}
;

Paralist2::=
Para:h COMMA Paralist2:t
{: RESULT = new Declist(h,t) ;:}
|
Para:h
{: RESULT = new Declist(h,new Declist()) ;:};


Para::=
IDENT:idt COLON Typ:tipe
{: RESULT = new ParDec(idt.left,idt.right,idt,tipe,false);:}
|
REF IDENT:idt COLON Typ:tipe
{: RESULT = new ParDec(idt.left,idt.right,idt,tipe,true);:}
;


StmtList::=
{: RESULT = new StmList() ;:}
|
Stmt:h StmtList:t
{: RESULT = new StmList((Stm h)h, (StmList t)t) ;:};


Stmt::=
IfStmt:i
{: RESULT = i; :}
|
WhileStmt: w
{: RESULT = w; :}
|
AssignStmt: a
{: RESULT = a; :}
|
ProcCall: pc
{: RESULT = pc; :}
|
CompoundStmt:c
{:RESULT = c:}
SEMIC:
:s
{: RESULT = new EmptyStm (s.left,s.right) ; :}
;

IfStmt::=IF:i LPAREN Expressions:t RPAREN Stmt:s1 OptElse:s2
{: RESULT = new IfStmt (i.left,i.right,(Exp)t,(Stm)s1,(Stm)s2 ;:};


OptElse::=
{: RESULT = new EmptyStm(left,right) ;:}
|
ELSE:t Stmt:s1
{: RESULT = s1;:}
;


WhileStmt::=
WHILE:w LPAREN Expressions:t RPAREN Stmt:b
{: RESULT = new WhileStmt (w.left,w.right,(Exp)t,(Stm)b ;};

AssignStmt::=
  LeftHandSide:l ASGN RightHandSide:r
  {: RESULT = new AssignStmt(l.left,r.right, (Var)l, (Exp)r) ;:}
  ;


CompoundStmt::=
LCURL:i StmtList:s RCURL
{:RESULT = new CompStm(i.left,i.right,(StmList)s):}
;

ProcCall::=
IDENT:i LPAREN Paralist:n RPAREN SEMIC
{: RESULT = new CallStm(i.left,i.right,(Sym)i, (ExpList)n ;:}
;

LeftHandSide::=
Variable:v
{: RESULT = v ;:};

Variable::=
IDENT:id
{: RESULT = new SimpleVar(id.left,id.right,(Sym)id ;:}
|
VariableArray:va
{: RESULT = va ;:}
;

VariableArray::= VariableArray:va LBRACK Expressions:exp RBRACK
{: RESULT = new ArrayVar(va.left,va.right,(Var)va,(Exp)exp) ;:}
|
IDENT:arrIdent LBRACK Expressions:arrID RBRACK
{: RESULT = new ArrayVar(arrIdent.left,arrIdent.right, arrIdent, arrID) ;:}
;

RightHandSide::=Expressions:exp
{: RESULT = exp ;:}
;


Expressions::=
Expressions:expOne LT:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne LE:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne GE:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne GT:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne NE:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne EQ:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne MINUS:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne PLUS:OP Expressions:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
ExpressionsOne:eo
{:RESULT = eo;:}
;

ExpressionsOne::=
Expressions:expOne STAR:OP ExpressionTwo:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
Expressions:expOne SLASH:OP ExpressionTwo:expTwo
{:RESULT = new OpExp(expOne.left,expOne.right,OP,expOne,expTwo);:}
|
ExpressionTwo:et
{:RESULT = et ;:}
;

ExpressionTwo::=
MINUS INTLIT:expint
{: RESULT = new IntExp(expint.left,expint.right,0 - expint);:}|
INTLIT:expInt
{: RESULT= new IntExp(expInt.left,expInt.right, expInt) ;:}
|
Variable:ExpVar
{: RESULT= new VarExp(ExpVar.left,ExpVar.right, (Var))expVar) ;:}
|
VariableArray:varar
{:RESULT = varar;:}|
LPAREN Expressions:e RPAREN
{:RESULT = e ;:}
;
